\documentclass[draft]{article}

\usepackage{url}

\begin{document}

\title{Computing Science Major Learning Outcomes}
\author{Richard Vaughan, Brad Bart}
\maketitle

\section{Purpose}

This document collects the Learning Outcomes (LOs) proposed by SFU CS
faculty members for any major in Computing Science. This collection is
for comparison with the combined LOs for the individual courses.

% add your name here whether or not you modify the LOs

\section{Learning Outcomes}

On graduation with any SFU Computing Science major, a student will:

\begin{enumerate}

\item be literate and articulate in English and mathematics

\item be able to answer the following questions both in overview to a layperson, and in technical detail:
  \begin{enumerate}
    \item How does a current desktop computer work?
    \item How does the internet work?
  \end{enumerate}

\item understand use the scientific method; including:
  \begin{enumerate}
    \item be able to state the method and its limitations
    \item apply the method to solve problems
    \item be able to design and perform an experiment then analyze and present the results in a scholarly manner
    \end{enumerate}

\item be able to apply mathematical techniques to solve real-world problems, including:
  \begin{enumerate}
    \item basic differential and integral calculus
    \item linear algebra
    \item two- and three-dimensional trigonometry
    \item multivariate statistics.
    \item probability
    \item be able to apply Bayes' theorem to calculate posterior probability distributions from priors.
  \end{enumerate}

\item be able to do basic Software Engineering, including:
  \begin{enumerate}
    \item be able to decompose problems into tractable, functional components
    \item be able to design, write, test and debug computer programs that implement the above

    \item understand the distinctive features of the major programming
      language paradigms, and be able to select an appropriate language
      to fit a problem decomposition, including:
      \begin{enumerate}
        \item imperative
        \item functional
        \item declarative
      \end{enumerate}

   \item recognize and characterize software development methodologies
    \item be able to write a high-quality $>$500 line program
    \item have basic experience of team work on program design and code projects
\end{enumerate}


\item understand the performance characteristics and other dynamic
  properties of algorithms and data structures, including:

  \begin{enumerate}
    \item be able to identify and categorize algorithms by asymptotic run-time analysis.

      \item understand and be able to apply basic alogorithms appropriately, including examples of:
       \begin{enumerate}  
         \item sorting
         \item search and other graph optimization methods
        \end{enumerate}

   \item be able to identify and categorize basic data structures according to their performance characteristics. These include:
    \begin{enumerate}  
      \item vector/array
      \item queue (FIFO, stack)
      \item singly- and doubly-linked list
      \item tree
      \item binary tree
      \item B-tree
      \item hash table
    \end{enumerate}

\item understand the distinctive features and  problems of distributed systems, including:
    \begin{enumerate}  
      \item synchronization, coordination and agreement
      \item consistency models
      \item limitations on parallelism
    \end{enumerate}        

  \end{enumerate}

 \item understand the basic formal results of computer science and their implications, including:
    \begin{enumerate} 
      \item Computability theory, including:
        \begin{enumerate}
          \item Godel's Incompleteness theorem
          \item the Church-Turing thesis
        \end{enumerate}

      \item Computation Complexity theory, including:
        \begin{enumerate}
          \item the notions of worst-, best- and average-case performance;
          \item the complexity classes, including NL, P, NP
        \end{enumerate}

     \item to support the above, the notions of:
       \begin{enumerate}
         \item formal machines, including:
           \begin{enumerate}
             \item the (deterministic) Turing machine
             \item linear automata
             \item pushdown automata
             \item finite-state automata
            \end{enumerate}
      
        \item formal grammars, including:
          \begin{enumerate}
            \item recursively enumerable grammars
            \item context-sensitive grammars
            \item context-free grammars
            \item regular grammars
           \end{enumerate}
     \end{enumerate}
      
  \end{enumerate}


\end{enumerate}

\section{Desirable, but not essential}

\begin{enumerate}

\item Be able to answer the following questions: 

  \begin{enumerate}
    \item How does computer graphics work?
    \item How does a smartphone work?
    \item What is Artificial Intelligence and how does it work?
  \end{enumerate}

\end{enumerate}

\section*{Brad scratch}


\subsection{pragmatic topics}

\begin{itemize}
\item why are some computing problems impossible?
\item a survey of what it means to be "hard"?
\item NP-completeness?
\item incomputability?
\item how does linux work? (or how does Windows work?)
\item file system?
\item device drivers?
\item how does it run your programs?
\item how does your cell phone work?
\item networking and wireless?
\item java interpreter?
\item device drivers?
\item how to become a wizard?
\item tool building?
\item hackers and security holes?
\item low level programs \& assembly?
\item how to build a large project?
\item why makes one algorithm better than another?
\item the acid test for when something is "slow"?
\item divide and conquer!

\item desirable but not essential:
\item how does the web work?
\item how do graphics render?
\item encodings?
\item cameras?
\item aliasing?
\end{itemize}

\subsection{topics list}

\begin{itemize}
\item induction
\item logic
\item intro probability
\item intro calculus
\item intro linear algebra

\item recursion
\item tree searching \& applications
\item functional programming
\item map / reduce
\item programming language paradigms - imperative / functional / declarative

\item big-O and analysis
\item algorithm proofs
\item graph theory, graph algorithms
\item divide and conquer
\item greedy
\item dynamic programming
\item NP-completeness
\item computability / diagonalization
\item automata: DFA, PDA, Turing Machine

\item interpreters and compilers
\item the software cycle, including linking and loading
\item languages, parsing and automata
\item concurrent programming \& locking
\item software engineering principles
\item students should have the capacity / experience to code a 500-line program with both accuracy and comfort
\item hardware design
\item assembly language
\item command line techniques
\item memory organization \& caches
\item multicore
\item database transactions
\item database organization
\item security
\end{itemize}

\section{Contributing Faculty members}

\begin{enumerate}
\item Bart 
\item Vaughan
\end{enumerate}

  
\end{document}
